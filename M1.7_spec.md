# Milestone 1.7 Specification: Baseline Relevance (Keyword/TF-IDF) per Topic

## Overview

**Goal:** Implement a deterministic baseline relevance scoring mechanism per topic using keyword matching and/or TF-IDF to rank articles.

**Duration:** 2 days

**Dependencies:**

- Milestone 1.5 (Normalization & Dedup)
- Milestone 1.6 (10+ Feeds & Robustness)

## Objectives

- Define topic model with keyword bags
- Implement a scoring function combining recency and keyword/TF-IDF relevance
- Provide an API or CLI to retrieve top N relevant articles for a topic
- Deterministic results given the same inputs

## Technical Requirements

### 1. Project Structure

Add a simple ranker module:

```
backend/
├── app/
│   ├── ranking/
│   │   ├── __init__.py
│   │   ├── text_utils.py      # tokenization, TF-IDF utilities
│   │   ├── relevance.py       # keyword/TF-IDF relevance scoring
│   │   └── ranker.py          # recency + relevance combined score
│   ├── api/
│   │   └── ranking.py         # (Optional) GET /topics/{id}/candidates?limit=10
│   └── core/
│       └── config.py          # Ranking weights
└── tests/
    ├── test_relevance.py
    └── test_ranker.py
```

### 2. Text Preparation

- Use normalized `title`, `summary_raw` (sanitized from M1.5) as text corpus
- Unicode normalization (NFKC) prior to tokenization
- Tokenization: lowercase, remove punctuation, fixed stopword list (documented set)
- Optional stemming/lemmatization is not required for MVP

### 3. Relevance Scoring

Two baseline modes (configurable):

1. Keyword Match Score
   - For topic keywords `K = {k1, k2, ...}` compute score as term frequency match in title + summary
   - Weight title matches higher than summary (e.g., title weight 2.0)
   - Normalize by document length to avoid bias toward long summaries

2. TF-IDF Cosine Similarity
   - Build TF-IDF vector for corpus of recent articles (rolling window, e.g., last 7 days)
   - Build a topic vector from its keywords (as a pseudo-document)
   - Score via cosine similarity

Configuration selects `RANKING_MODE = "keywords" | "tfidf"` (default `keywords`).

### 4. Recency Boost

Combine relevance with a recency factor to prefer newer items:

```text
final_score = relevance_score * W_rel + recency_boost(published_at) * W_rec
```

Where `recency_boost(t)` decays over time (exponential decay): `exp(-ln(2) * hours_since_t / halflife_hours)` using UTC timestamps.

Default weights: `W_rel = 0.7`, `W_rec = 0.3`.

### 5. Retrieval and Ranking

- Query candidate articles from DB within a time window (e.g., last 7 days)
- Compute scores, sort descending, return top N (default 10)
- Ensure deterministic ordering by tie-breaker: `published_at desc, id asc`

TF-IDF determinism and caching:

- Compute IDF once at the start of each ranking session using a snapshot of articles from the time window
- Use this IDF snapshot throughout the entire ranking operation to ensure consistency
- Cache IDF vectors for 1-hour windows to balance freshness vs. performance:
  ```python
  # IDF cache key: "idf:{start_timestamp}:{end_timestamp}:{hash(article_ids)}"
  # This ensures the same corpus produces the same IDF even if new articles arrive mid-ranking
  ```
- Optionally precompute IDF every hour for high-traffic scenarios

CLI for testing:

```bash
conda run -n ymb-py311 python -m app.ranking.ranker --topic-id 1 --limit 10 --mode keywords
```

### 6. Configuration

Add to `core/config.py`:

- `RANKING_MODE` ("keywords" or "tfidf")
- `RANKING_TIME_WINDOW_DAYS` (default 7)
- `RANKING_TITLE_WEIGHT` (default 2.0)
- `RANKING_WEIGHTS_REL` (0.7) and `RANKING_WEIGHTS_REC` (0.3)
- `RECENCY_HALFLIFE_HOURS` (default 48)
- `STOPWORDS` (fixed list) for deterministic preprocessing
- `IDF_CACHE_TTL_SECONDS` (default 3600) for IDF vector caching
- `IDF_CACHE_ENABLED` (default True) to enable/disable caching

### 7. API (Optional in M1.7)

Provide an internal API for testing:

- `GET /topics/{id}/candidates?limit=10&mode=keywords`
  - Returns top N articles with `score`, `relevance_score`, `recency_score`
  - Deterministic response with pagination limits; default `limit<=50`

## Testing Requirements

### Unit Tests

- Keyword scoring: higher scores for more keyword matches and title matches
- TF-IDF: cosine similarity behaves as expected with toy corpus
- Recency: newer items get higher recency boost
- Deterministic ordering with tie-breakers
- Multi-word keyword handling and phrase boundary checks

### Integration Tests

- Given a topic with keywords, ranking returns expected top N from a seeded dataset
- Switching modes changes ordering predictably

## Quality Gates

### Code Quality

- `ruff`/`black`/`mypy` pass

### Performance

- Ranking over 1k recent articles completes in < 500ms on dev machine

## Acceptance Criteria

1. Deterministic top 10 articles given a topic and inputs
2. Keyword mode and TF-IDF mode both functional (configurable)
3. Recency boost correctly influences final ordering
4. Tests validate expected behavior

## Deliverables

1. `app/ranking/` modules and optional `api/ranking.py`
2. Config entries for ranking/recency
3. Tests for relevance and ranker

## Success Metrics

- ✅ For a topic with keywords, top 10 are returned deterministically
- ✅ Ranking completes within performance bounds
- ✅ All CI checks pass

## Next Steps

- **Milestone 1.8:** Add summarization for candidates and store in `article_summaries`
- **Milestone 2.2:** Use the ranker to select daily top-3 per topic
